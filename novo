<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8">
<title>Cifras Canto Catequese — PDF + Áudio + Playlists</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
*{box-sizing:border-box}
:root{
  --bg:#f7fafc; --text:#0f172a; --muted:#475569;
  --card:#ffffff; --line:#e2e8f0; --primary:#0ea5e9; --danger:#ef4444;
}
html,body{margin:0;height:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--text)}
a{color:inherit}
.app{min-height:100%;display:grid;grid-template-rows:auto auto 1fr auto}

header{padding:16px 16px 10px;background:#0f172a;color:#fff;text-align:center}
header h1{margin:0;font-size:22px}
.subtitle{opacity:.9;margin:4px 0 0}

.tabs{display:grid;grid-template-columns:1fr 1fr 1fr 1fr}
.tabs button{padding:12px;border:0;background:#e2e8f0;color:#0f172a;cursor:pointer;font-weight:700}
.tabs button.active{background:var(--primary);color:#fff}

main{padding:14px}
.tab{display:none}
.tab.active{display:block}
.card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:12px}

input,select,textarea,button{width:100%;padding:10px;border-radius:10px;border:1px solid var(--line);background:#fff}
button{cursor:pointer}
.btn-danger{background:var(--danger);color:#fff;border-color:var(--danger)}
.btn-primary{background:var(--primary);color:#fff;border-color:var(--primary)}
.actions{display:flex;gap:10px;margin-top:10px}
.actions-row{display:flex;gap:8px;align-items:center}

.filters{display:flex;gap:8px;margin-bottom:10px}
.list{list-style:none;margin:0;padding:0;display:grid;gap:10px}
.list li{background:var(--card);border:1px solid var(--line);padding:12px;border-radius:12px;display:grid;gap:6px}
.song-row{display:flex;gap:8px;justify-content:space-between;align-items:flex-start}
.song-title{font-weight:800}
.song-meta{font-size:13px;color:var(--muted)}
.badge{display:inline-block;background:#eef2f7;border:1px solid var(--line);padding:2px 8px;border-radius:999px;margin-right:6px;font-size:12px}

.chips{display:flex;gap:6px;flex-wrap:wrap;margin-bottom:10px}
.chip{border:1px solid var(--line);padding:4px 10px;border-radius:999px;background:#fff;cursor:pointer}
.chip.active{background:var(--primary);color:#fff;border-color:var(--primary)}

.grid{display:grid;gap:12px}
.grid-2{grid-template-columns:1fr 1fr}
@media (max-width:980px){.grid-2{grid-template-columns:1fr}}

.pdfhint{font-size:12px;color:var(--muted);margin-top:6px}

.viewer{display:grid;gap:12px}
.viewer .row{display:grid;grid-template-columns:2fr 1fr;gap:12px}
@media (max-width:980px){.viewer .row{grid-template-columns:1fr}}
.viewer .pdf{height:70vh;border:1px solid var(--line);border-radius:10px;overflow:hidden;background:#fff;position:relative}
.viewer .pdf iframe{width:100%;height:100%;border:0}
.viewer .pdf .float-toolbar{position:absolute;top:8px;right:8px;display:flex;gap:8px}
.viewer .audio{background:#fff;border:1px solid var(--line);border-radius:10px;padding:12px}

footer{padding:12px;text-align:center;color:var(--muted)}

/* Modal base */
.modal{position:fixed;inset:0;background:rgba(0,0,0,.45);display:none;align-items:center;justify-content:center;padding:16px}
.modal .content{background:#fff;max-width:1100px;width:100%;border-radius:16px;padding:16px;position:relative;border:1px solid var(--line)}
.modal .close{position:absolute;top:8px;right:10px;border:0;background:transparent;font-size:20px;cursor:pointer}
.modal h2{margin:0 0 4px 0}
.modal .meta{color:#475569;margin-bottom:10px}
.modal .tags{font-size:12px;color:#475569}

/* Modal seletor de playlists */
#playlistPicker .content{max-width:520px}
.pill{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--line);border-radius:999px;padding:6px 10px;background:#fff}
.pill .count{font-size:12px;color:#475569}
.scroll{max-height:50vh;overflow:auto}
.small{font-size:12px;color:#475569}
.inline{width:auto;padding:6px 10px}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Cifras Canto Catequese</h1>
    <p class="subtitle">PDF da cifra/partitura + Áudio MP3 • Categorias, Tags e Playlists • Offline.</p>
  </header>

  <nav class="tabs">
    <button data-tab="library" class="active">Biblioteca</button>
    <button data-tab="create">Nova Música</button>
    <button data-tab="playlists">Playlists</button>
    <button data-tab="manage">Categorias/Backup</button>
  </nav>

  <main>
    <!-- Biblioteca -->
    <section id="tab-library" class="tab active">
      <div class="card">
        <div class="filters">
          <input id="search" placeholder="Buscar por título, artista ou tag...">
          <select id="categoryFilter"><option value="">Todas as categorias</option></select>
        </div>
        <div id="tagChips" class="chips"></div>
        <ul id="songList" class="list"></ul>
      </div>
    </section>

    <!-- Nova música -->
    <section id="tab-create" class="tab">
      <div class="card">
        <div class="grid grid-2">
          <label>Título
            <input id="title" required>
          </label>
          <label>Artista
            <input id="artist">
          </label>
        </div>

        <div class="grid grid-2">
          <label>Categoria
            <select id="category"></select>
          </label>
          <label>Tags (separe por vírgula)
            <input id="tags" placeholder="louvor, missa, entrada...">
          </label>
        </div>

        <div class="grid grid-2">
          <label>Documento PDF da cifra/partitura
            <input id="pdfInput" type="file" accept="application/pdf">
          </label>
          <label>Áudio (MP3/WAV/OGG)
            <input id="audioInput" type="file" accept="audio/*">
          </label>
        </div>
        <div class="pdfhint">O PDF e o áudio ficam guardados no navegador (IndexedDB). Arquivos grandes ocupam mais espaço.</div>

        <div class="actions">
          <button class="btn-primary" id="saveSong">Salvar</button>
          <button id="clearForm">Limpar</button>
        </div>
      </div>
    </section>

    <!-- Playlists -->
    <section id="tab-playlists" class="tab">
      <div class="card">
        <h3>Playlists</h3>
        <div class="actions-row" style="margin-bottom:8px">
          <input id="newPlaylistName" placeholder="Nome da nova playlist..." style="max-width:360px">
          <button class="inline btn-primary" id="btnCreatePlaylist">Criar</button>
        </div>

        <div id="playlistList" class="list"></div>
      </div>
    </section>

    <!-- Gerenciar -->
    <section id="tab-manage" class="tab">
      <div class="card">
        <h3>Categorias</h3>
        <div class="actions" style="margin-top:0">
          <input id="newCategory" placeholder="Nova categoria...">
          <button id="addCategory">Adicionar</button>
        </div>
        <ul id="categoryList" class="list" style="margin-top:10px"></ul>

        <hr style="margin:18px 0;border:none;border-top:1px solid var(--line)">
        <h3>Backup</h3>
        <div class="actions" style="margin-top:8px">
          <button id="exportMeta">Exportar (apenas metadados)</button>
          <button id="exportAll">Exportar (com arquivos)</button>
          <input id="importFile" type="file" accept="application/json">
          <button id="importData">Importar</button>
        </div>
        <p class="pdfhint">
          “Com arquivos” gera um JSON grande (inclui PDFs/áudios em base64). Use para migrar de navegador.
        </p>
      </div>
    </section>

    <!-- Modal / Viewer de música -->
    <div id="modal" class="modal">
      <div class="content">
        <button class="close" id="modalClose">×</button>
        <h2 id="mTitle">Título</h2>
        <div class="meta" id="mMeta"></div>
        <div class="tags" id="mTags"></div>

        <div class="viewer" style="margin-top:10px">
          <div class="row">
            <div class="pdf" id="pdfViewer">
              <div class="float-toolbar">
                <button id="btnFullscreen" class="inline">Tela cheia</button>
                <button id="btnOpenPDF" class="inline">Abrir em nova aba</button>
              </div>
              <!-- iframe do PDF é injetado via JS -->
            </div>
            <div class="audio">
              <audio id="mAudio" controls style="width:100%"></audio>
              <div class="pdfhint" style="margin-top:6px">
                <button id="btnDownloadAll" class="inline">Baixar PDF + Áudio</button>
              </div>
            </div>
          </div>
        </div>

        <div class="actions" style="margin-top:12px">
          <button id="editSong">Editar</button>
          <button id="deleteSong" class="btn-danger">Excluir</button>
        </div>
      </div>
    </div>

    <!-- Modal seletor de playlist -->
    <div id="playlistPicker" class="modal">
      <div class="content">
        <button class="close" id="pickerClose">×</button>
        <h3>Adicionar à playlist</h3>
        <div class="actions-row" style="margin:8px 0 10px 0">
          <input id="pickerNewName" placeholder="Criar nova playlist..." style="max-width:320px">
          <button id="pickerCreate" class="inline btn-primary">Criar</button>
        </div>
        <div id="pickerList" class="scroll"></div>
      </div>
    </div>

  </main>

  <footer><small>Cifras Canto Catequese – v2.2 • PDF + Áudio + Playlists • Dados locais (IndexedDB).</small></footer>
</div>

<script>
/* ===================== IndexedDB Helper ===================== */
const DB = (() => {
  const DB_NAME = 'CifrasWebDB';
  const DB_VER = 3; // nova versão (adicionando playlists na meta)
  let db;

  function open(){
    return new Promise((resolve,reject)=>{
      const req = indexedDB.open(DB_NAME, DB_VER);
      req.onupgradeneeded = (e)=>{
        db = e.target.result;
        if (!db.objectStoreNames.contains('songs')) {
          const s = db.createObjectStore('songs', { keyPath: 'id' });
          s.createIndex('title','title',{unique:false});
        }
        if (!db.objectStoreNames.contains('meta')) {
          db.createObjectStore('meta', { keyPath: 'key' }); // {key:'categories'|'tags'|'playlists'}
        }
      };
      req.onsuccess = ()=>{ db = req.result; resolve(); };
      req.onerror = ()=> reject(req.error);
    });
  }
  const tx = (store,mode='readonly') => db.transaction(store,mode).objectStore(store);

  // Songs
  const listSongs = () => new Promise((resolve,reject)=>{
    const out=[]; const r = tx('songs').openCursor();
    r.onsuccess = e => { const c = e.target.result; if(c){ out.push(c.value); c.continue(); } else resolve(out); };
    r.onerror = e => reject(e.target.error);
  });
  const getSong = id => new Promise((resolve,reject)=>{
    const r = tx('songs').get(id); r.onsuccess = ()=> resolve(r.result); r.onerror = ()=> reject(r.error);
  });
  const saveSong = song => new Promise((resolve,reject)=>{
    const s = tx('songs','readwrite'); if(!song.id) song.id = 's_'+Date.now()+'_'+Math.random().toString(36).slice(2,8);
    const r = s.put(song); r.onsuccess = ()=> resolve(song); r.onerror = ()=> reject(r.error);
  });
  const deleteSong = id => new Promise((resolve,reject)=>{
    const r = tx('songs','readwrite').delete(id); r.onsuccess=()=>resolve(); r.onerror=()=>reject(r.error);
  });

  // Meta
  const getMeta = key => new Promise((resolve,reject)=>{ const r = tx('meta').get(key); r.onsuccess=()=>resolve(r.result?r.result.value:null); r.onerror=()=>reject(r.error); });
  const setMeta = (key,value) => new Promise((resolve,reject)=>{ const r = tx('meta','readwrite').put({key,value}); r.onsuccess=()=>resolve(); r.onerror=()=>reject(r.error); });

  return { open, listSongs, getSong, saveSong, deleteSong, getMeta, setMeta };
})();

/* ===================== Estado / Elementos ===================== */
const State = {
  filterCat:'', filterTag:'', search:'',
  currentSong:null, editingId:null,
  urls: new Map(), // id -> {pdfURL, audioURL}
  pickerSongId: null
};
const els = {};
function elcache(){
  els.tabs = document.querySelectorAll('.tabs button');
  els.sections = {
    library: byId('tab-library'),
    create: byId('tab-create'),
    manage: byId('tab-manage'),
    playlists: byId('tab-playlists'),
  };
  // library
  els.search = byId('search'); els.categoryFilter = byId('categoryFilter');
  els.tagChips = byId('tagChips'); els.songList = byId('songList');
  // form
  els.title = byId('title'); els.artist = byId('artist'); els.category = byId('category');
  els.tags = byId('tags'); els.pdfInput = byId('pdfInput'); els.audioInput = byId('audioInput');
  els.saveSong = byId('saveSong'); els.clearForm = byId('clearForm');
  // manage
  els.newCategory = byId('newCategory'); els.addCategory = byId('addCategory');
  els.categoryList = byId('categoryList'); els.exportMeta = byId('exportMeta'); els.exportAll = byId('exportAll');
  els.importFile = byId('importFile'); els.importData = byId('importData');
  // playlists tab
  els.newPlaylistName = byId('newPlaylistName'); els.btnCreatePlaylist = byId('btnCreatePlaylist');
  els.playlistList = byId('playlistList');
  // modal música
  els.modal = byId('modal'); els.modalClose = byId('modalClose');
  els.mTitle = byId('mTitle'); els.mMeta = byId('mMeta'); els.mTags = byId('mTags');
  els.pdfViewer = byId('pdfViewer'); els.mAudio = byId('mAudio');
  els.editSong = byId('editSong'); els.deleteSong = byId('deleteSong');
  els.btnOpenPDF = byId('btnOpenPDF'); els.btnDownloadAll = byId('btnDownloadAll'); els.btnFullscreen = byId('btnFullscreen');
  // playlist picker
  els.playlistPicker = byId('playlistPicker'); els.pickerClose = byId('pickerClose');
  els.pickerNewName = byId('pickerNewName'); els.pickerCreate = byId('pickerCreate'); els.pickerList = byId('pickerList');
}

/* ===================== Boot ===================== */
document.addEventListener('DOMContentLoaded', async ()=>{
  await DB.open();
  elcache();
  bindEvents();
  await ensureDefaults();
  await refreshCategories();
  await refreshTagsChips();
  await renderList();
  await renderPlaylists();
});

/* ===================== Defaults ===================== */
async function ensureDefaults(){
  if (!(await DB.getMeta('categories'))) await DB.setMeta('categories', ['Geral','Louvor','Missa','Ensaios']);
  if (!(await DB.getMeta('tags'))) await DB.setMeta('tags', ['entrada','ofertório','comunhão','final']);
  if (!(await DB.getMeta('playlists'))) await DB.setMeta('playlists', []); // {id,name,songIds:[]}
}

/* ===================== Events ===================== */
function bindEvents(){
  // tabs
  document.querySelectorAll('.tabs button').forEach(btn=> btn.addEventListener('click', ()=>switchTab(btn.dataset.tab, btn)));

  // filtros
  els.search.addEventListener('input', ()=>{ State.search = els.search.value.trim().toLowerCase(); renderList(); });
  els.categoryFilter.addEventListener('change', ()=>{ State.filterCat = els.categoryFilter.value; renderList(); });

  // form
  els.saveSong.addEventListener('click', saveCurrentSong);
  els.clearForm.addEventListener('click', clearForm);

  // manage
  els.addCategory.addEventListener('click', addCategory);
  els.exportMeta.addEventListener('click', ()=> exportData(false));
  els.exportAll.addEventListener('click', ()=> exportData(true));
  els.importData.addEventListener('click', importData);

  // modal música
  els.modalClose.addEventListener('click', closeModal);
  els.editSong.addEventListener('click', ()=> loadSongIntoForm(State.currentSong));
  els.deleteSong.addEventListener('click', deleteCurrentSong);
  els.btnOpenPDF.addEventListener('click', ()=> {
    const u = State.urls.get(State.currentSong?.id); if (u?.pdfURL) window.open(u.pdfURL,'_blank');
  });
  els.btnDownloadAll.addEventListener('click', downloadCurrentFiles);
  els.btnFullscreen.addEventListener('click', toggleFullscreenPDF);

  // playlists tab
  els.btnCreatePlaylist.addEventListener('click', createPlaylistFromTab);

  // playlist picker
  els.pickerClose.addEventListener('click', closePicker);
  els.pickerCreate.addEventListener('click', createPlaylistFromPicker);
}

/* ===================== Categorias/Tags ===================== */
async function getCategories(){ return (await DB.getMeta('categories')) || []; }
async function setCategories(list){ await DB.setMeta('categories', list); }

async function refreshCategories(){
  const cats = await getCategories();
  els.category.innerHTML = cats.map(c=>`<option>${escapeHtml(c)}</option>`).join('');
  els.categoryFilter.innerHTML = `<option value="">Todas as categorias</option>` + cats.map(c=>`<option>${escapeHtml(c)}</option>`).join('');
  els.categoryList.innerHTML = cats.map(c=>`
    <li class="actions" style="align-items:center;justify-content:space-between">
      <span>${escapeHtml(c)}</span>
      <button data-cat="${escapeHtml(c)}" class="btn-danger inline">Remover</button>
    </li>`).join('');
  els.categoryList.querySelectorAll('button').forEach(b=>{
    b.addEventListener('click', async ()=>{
      const list = (await getCategories()).filter(x=>x!==b.dataset.cat);
      await setCategories(list); await refreshCategories(); await renderList();
    });
  });
}
async function addCategory(){
  const name = (els.newCategory.value||'').trim(); if (!name) return;
  const set = new Set(await getCategories()); set.add(name);
  await setCategories(Array.from(set).sort()); els.newCategory.value=''; await refreshCategories();
}
async function refreshTagsChips(){
  const tags = (await DB.getMeta('tags')) || [];
  const all = ['todas', ...tags];
  els.tagChips.innerHTML = all.map(t=>{
    const val = t==='todas'?'':t; const cls = (State.filterTag===val)?'chip active':'chip';
    return `<span class="${cls}" data-tag="${escapeHtml(val)}">${escapeHtml(t)}</span>`;
  }).join('');
  els.tagChips.querySelectorAll('.chip').forEach(ch=>{
    ch.addEventListener('click', ()=>{ State.filterTag = ch.dataset.tag || ''; refreshTagsChips(); renderList(); });
  });
}

/* ===================== Lista / Biblioteca ===================== */
async function renderList(){
  const items = await DB.listSongs();
  items.sort((a,b)=> (a.title||'').localeCompare(b.title||''));
  const f = items.filter(it=>{
    const catOk = !State.filterCat || it.category===State.filterCat;
    const tagOk = !State.filterTag || (it.tags||[]).includes(State.filterTag);
    const q = State.search;
    const searchOk = !q || [it.title,it.artist,...(it.tags||[])].some(v=>(v||'').toLowerCase().includes(q));
    return catOk && tagOk && searchOk;
  });
  els.songList.innerHTML = f.map(it=> songItemHTML(it)).join('');
  // binds
  els.songList.querySelectorAll('[data-open]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.closest('li').dataset.id;
      const song = await DB.getSong(id);
      openModal(song);
    });
  });
  els.songList.querySelectorAll('[data-addtoplaylist]').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      const id = btn.closest('li').dataset.id;
      openPicker(id);
    });
  });
}
function songItemHTML(it){
  const tags = (it.tags||[]).map(t=>`<span class="badge">${escapeHtml(t)}</span>`).join('');
  return `
  <li data-id="${it.id}">
    <div class="song-row">
      <div>
        <div class="song-title">${escapeHtml(it.title||'Sem título')}</div>
        <div class="song-meta">${escapeHtml(it.artist||'Sem artista')} • ${escapeHtml(it.category||'Sem categoria')}</div>
        <div class="song-meta">${tags}</div>
      </div>
      <div class="actions-row">
        <button class="inline" data-addtoplaylist>+ Playlist</button>
        <button class="inline btn-primary" data-open>Abrir</button>
      </div>
    </div>
  </li>`;
}

/* ===================== Modal / Viewer Música ===================== */
function openModal(song){
  State.currentSong = song;
  els.mTitle.textContent = song.title || 'Sem título';
  els.mMeta.textContent = `${song.artist||'Sem artista'} • ${song.category||'Sem categoria'}`;
  els.mTags.textContent = (song.tags||[]).join(', ') || 'Sem tags';

  // revoke antigos
  const prev = State.urls.get(song.id) || {};
  if (prev.pdfURL) URL.revokeObjectURL(prev.pdfURL);
  if (prev.audioURL) URL.revokeObjectURL(prev.audioURL);
  const pdfURL = song.pdfBlob ? URL.createObjectURL(song.pdfBlob) : '';
  const audioURL = song.audioBlob ? URL.createObjectURL(song.audioBlob) : '';
  State.urls.set(song.id, {pdfURL, audioURL});

  // PDF
  els.pdfViewer.querySelector('iframe')?.remove();
  if (pdfURL){
    const ifr = document.createElement('iframe');
    ifr.src = pdfURL + '#toolbar=1&navpanes=0&scrollbar=1';
    ifr.title = 'PDF';
    els.pdfViewer.appendChild(ifr);
  } else {
    els.pdfViewer.innerHTML = `<div class="pdfhint" style="padding:10px">Nenhum PDF anexado.</div>`;
  }

  // Áudio
  if (audioURL){ els.mAudio.src = audioURL; els.mAudio.style.display='block'; }
  else { els.mAudio.removeAttribute('src'); els.mAudio.style.display='none'; }

  els.modal.style.display='flex';
}
function closeModal(){
  els.modal.style.display='none';
  els.mAudio.pause?.();
  State.currentSong = null;
}
function toggleFullscreenPDF(){
  const el = els.pdfViewer;
  if (!document.fullscreenElement){
    el.requestFullscreen?.();
  } else {
    document.exitFullscreen?.();
  }
}

/* ===================== Form: salvar / limpar / editar ===================== */
async function saveCurrentSong(){
  const title = els.title.value.trim();
  if (!title){ alert('Informe o título.'); return; }

  const pdfFile = els.pdfInput.files?.[0] || null;
  const audioFile = els.audioInput.files?.[0] || null;

  const existing = State.editingId ? await DB.getSong(State.editingId) : {};
  const song = {
    id: State.editingId || null,
    title,
    artist: els.artist.value.trim(),
    category: els.category.value,
    tags: els.tags.value.split(',').map(t=>t.trim()).filter(Boolean),
    pdfBlob: pdfFile ? await fileToBlob(pdfFile) : (existing?.pdfBlob || null),
    pdfName: pdfFile ? pdfFile.name : (existing?.pdfName || ''),
    audioBlob: audioFile ? await fileToBlob(audioFile) : (existing?.audioBlob || null),
    audioName: audioFile ? audioFile.name : (existing?.audioName || ''),
    updatedAt: Date.now(),
    createdAt: State.editingId ? existing?.createdAt ?? Date.now() : Date.now(),
  };

  // atualizar tags sugeridas
  if (song.tags?.length){
    const cur = new Set((await DB.getMeta('tags')) || []);
    song.tags.forEach(t=> cur.add(t));
    await DB.setMeta('tags', Array.from(cur).sort());
    await refreshTagsChips();
  }

  await DB.saveSong(song);
  clearForm();
  switchTab('library');
  await renderList();
}
function clearForm(){
  State.editingId = null;
  els.title.value=''; els.artist.value=''; els.tags.value='';
  els.pdfInput.value=''; els.audioInput.value='';
}
function loadSongIntoForm(song){
  closeModal();
  switchTab('create');
  State.editingId = song.id;
  els.title.value = song.title||'';
  els.artist.value = song.artist||'';
  els.category.value = song.category||'';
  els.tags.value = (song.tags||[]).join(', ');
  els.pdfInput.value=''; els.audioInput.value='';
}

/* ===================== Excluir / Download ===================== */
async function deleteCurrentSong(){
  if (!State.currentSong?.id) return;
  if (!confirm('Excluir esta música?')) return;
  await DB.deleteSong(State.currentSong.id);
  // também remover dos playlists
  await removeSongFromAllPlaylists(State.currentSong.id);
  closeModal();
  await renderList(); await renderPlaylists();
}
function downloadCurrentFiles(){
  const s = State.currentSong; if (!s) return;
  const urls = State.urls.get(s.id)||{};
  if (s.pdfBlob){
    const a = document.createElement('a');
    a.href = urls.pdfURL || URL.createObjectURL(s.pdfBlob);
    a.download = s.pdfName || (s.title.replace(/\s+/g,'_')+'.pdf'); a.click();
  }
  if (s.audioBlob){
    const a = document.createElement('a');
    a.href = urls.audioURL || URL.createObjectURL(s.audioBlob);
    const ext = (s.audioBlob.type.split('/')[1]||'mp3');
    a.download = s.audioName || (s.title.replace(/\s+/g,'_')+'.'+ext); a.click();
  }
}

/* ===================== Playlists ===================== */
async function getPlaylists(){ return (await DB.getMeta('playlists')) || []; }
async function setPlaylists(arr){ await DB.setMeta('playlists', arr); }
function newPlaylistId(){ return 'p_'+Date.now()+'_'+Math.random().toString(36).slice(2,6); }

async function renderPlaylists(){
  const pls = await getPlaylists();
  if (!pls.length){
    els.playlistList.innerHTML = `<div class="pdfhint">Nenhuma playlist. Crie uma acima.</div>`;
    return;
  }
  els.playlistList.innerHTML = pls.map(pl=> playlistItemHTML(pl)).join('');
  // binds
  els.playlistList.querySelectorAll('[data-openpl]').forEach(btn=>{
    btn.addEventListener('click', ()=> openPlaylist(btn.dataset.openpl));
  });
  els.playlistList.querySelectorAll('[data-rename]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.dataset.rename;
      const pls = await getPlaylists();
      const pl = pls.find(p=>p.id===id); if(!pl) return;
      const name = prompt('Novo nome da playlist:', pl.name);
      if (!name) return;
      pl.name = name.trim();
      await setPlaylists(pls);
      await renderPlaylists();
    });
  });
  els.playlistList.querySelectorAll('[data-delpl]').forEach(btn=>{
    btn.addEventListener('click', async ()=>{
      const id = btn.dataset.delpl;
      if (!confirm('Excluir playlist? (As músicas permanecem salvas)')) return;
      const pls = (await getPlaylists()).filter(p=>p.id!==id);
      await setPlaylists(pls);
      await renderPlaylists();
    });
  });
}
function playlistItemHTML(pl){
  return `
  <div class="card" data-plid="${pl.id}">
    <div class="actions-row" style="justify-content:space-between">
      <div class="pill"><strong>${escapeHtml(pl.name)}</strong> <span class="count">(${pl.songIds?.length||0})</span></div>
      <div class="actions-row">
        <button class="inline" data-openpl="${pl.id}">Abrir</button>
        <button class="inline" data-rename="${pl.id}">Renomear</button>
        <button class="inline btn-danger" data-delpl="${pl.id}">Excluir</button>
      </div>
    </div>
  </div>`;
}
async function openPlaylist(id){
  const pls = await getPlaylists();
  const pl = pls.find(p=>p.id===id); if(!pl){ alert('Playlist não encontrada'); return; }
  // carregar músicas
  const all = await DB.listSongs();
  const songs = (pl.songIds||[]).map(sid => all.find(s=>s.id===sid)).filter(Boolean);
  // render simples dentro da própria card (expansível)
  const card = els.playlistList.querySelector(`[data-plid="${CSS.escape(id)}"]`);
  let html = `<ul class="list" style="margin-top:10px">`;
  if (!songs.length){
    html += `<li><div class="pdfhint">Nenhuma música nesta playlist.</div></li>`;
  } else {
    html += songs.map(s=>`
      <li data-sid="${s.id}">
        <div class="song-row">
          <div>
            <div class="song-title">${escapeHtml(s.title)}</div>
            <div class="song-meta">${escapeHtml(s.artist||'Sem artista')} • ${escapeHtml(s.category||'')}</div>
          </div>
          <div class="actions-row">
            <button class="inline" data-remove="${s.id}" data-pl="${id}">Remover</button>
            <button class="inline btn-primary" data-open-song="${s.id}">Abrir</button>
          </div>
        </div>
      </li>`).join('');
  }
  html += `</ul>`;
  // remove expansões antigas e injeta
  card.querySelector('ul')?.remove();
  card.insertAdjacentHTML('beforeend', html);
  // binds
  card.querySelectorAll('[data-open-song]').forEach(b=>{
    b.addEventListener('click', async ()=>{
      const s = await DB.getSong(b.dataset.openSong);
      openModal(s);
    });
  });
  card.querySelectorAll('[data-remove]').forEach(b=>{
    b.addEventListener('click', async ()=>{
      const sid = b.dataset.remove, pid = b.dataset.pl;
      await removeSongFromPlaylist(pid, sid);
      await openPlaylist(pid); // re-render
      await renderPlaylists(); // atualizar contagem
    });
  });
}

async function createPlaylistFromTab(){
  const name = (els.newPlaylistName.value||'').trim();
  if (!name) return;
  const pls = await getPlaylists();
  pls.push({id:newPlaylistId(), name, songIds:[]});
  await setPlaylists(pls);
  els.newPlaylistName.value='';
  await renderPlaylists();
}

/* ===== Picker (adicionar da Biblioteca) ===== */
function openPicker(songId){
  State.pickerSongId = songId;
  renderPicker();
  els.playlistPicker.style.display='flex';
}
function closePicker(){
  els.playlistPicker.style.display='none';
  State.pickerSongId = null;
}
async function renderPicker(){
  const pls = await getPlaylists();
  if (!pls.length){
    els.pickerList.innerHTML = `<div class="pdfhint">Nenhuma playlist. Crie uma acima e depois selecione.</div>`;
    return;
  }
  els.pickerList.innerHTML = pls.map(pl=>`
    <div class="actions-row" style="justify-content:space-between;margin-bottom:8px">
      <span class="pill"><strong>${escapeHtml(pl.name)}</strong> <span class="count">(${pl.songIds?.length||0})</span></span>
      <button class="inline" data-addpl="${pl.id}">Adicionar</button>
    </div>
  `).join('');
  els.pickerList.querySelectorAll('[data-addpl]').forEach(b=>{
    b.addEventListener('click', async ()=>{
      await addSongToPlaylist(b.dataset.addpl, State.pickerSongId);
      closePicker();
      await renderPlaylists();
    });
  });
}
async function createPlaylistFromPicker(){
  const name = (els.pickerNewName.value||'').trim(); if (!name) return;
  const pls = await getPlaylists();
  const id = newPlaylistId();
  pls.push({id, name, songIds:[]});
  await setPlaylists(pls);
  els.pickerNewName.value='';
  await renderPicker();
}
async function addSongToPlaylist(playlistId, songId){
  const pls = await getPlaylists();
  const pl = pls.find(p=>p.id===playlistId); if(!pl) return;
  pl.songIds = Array.from(new Set([...(pl.songIds||[]), songId]));
  await setPlaylists(pls);
}
async function removeSongFromPlaylist(playlistId, songId){
  const pls = await getPlaylists();
  const pl = pls.find(p=>p.id===playlistId); if(!pl) return;
  pl.songIds = (pl.songIds||[]).filter(id=>id!==songId);
  await setPlaylists(pls);
}
async function removeSongFromAllPlaylists(songId){
  const pls = await getPlaylists();
  let changed = false;
  for (const pl of pls){
    const newIds = (pl.songIds||[]).filter(id=>id!==songId);
    if (newIds.length !== (pl.songIds||[]).length){ pl.songIds = newIds; changed = true; }
  }
  if (changed) await setPlaylists(pls);
}

/* ===================== Backup Import/Export ===================== */
async function exportData(includeFiles){
  const songs = await DB.listSongs();
  const cats = await DB.getMeta('categories') || [];
  const tags = await DB.getMeta('tags') || [];
  const playlists = await DB.getMeta('playlists') || [];

  const payload = {
    version: '3-pdf-audio-playlists',
    exportedAt: new Date().toISOString(),
    includeFiles: !!includeFiles,
    categories: cats, tags, playlists,
    songs: await Promise.all(songs.map(async s=>{
      const base = {
        id: s.id, title: s.title, artist: s.artist, category: s.category, tags: s.tags||[],
        createdAt: s.createdAt, updatedAt: s.updatedAt,
        pdfName: s.pdfName||'', audioName: s.audioName||''
      };
      if (includeFiles){
        base.pdfB64 = s.pdfBlob ? await blobToBase64(s.pdfBlob) : '';
        base.pdfMime = s.pdfBlob ? s.pdfBlob.type : '';
        base.audioB64 = s.audioBlob ? await blobToBase64(s.audioBlob) : '';
        base.audioMime = s.audioBlob ? s.audioBlob.type : '';
      }
      return base;
    }))
  };

  const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = includeFiles ? 'cifras_backup_com_arquivos.json' : 'cifras_backup_meta.json';
  a.click(); URL.revokeObjectURL(url);
}
async function importData(){
  const file = els.importFile.files?.[0];
  if (!file){ alert('Selecione um arquivo JSON.'); return; }
  const text = await file.text();
  let data; try{ data = JSON.parse(text); }catch(e){ alert('JSON inválido.'); return; }
  if (!data || !Array.isArray(data.songs)){ alert('Backup inválido.'); return; }

  await DB.setMeta('categories', Array.from(new Set([...(await DB.getMeta('categories')||[]), ...data.categories||[]])).sort());
  await DB.setMeta('tags', Array.from(new Set([...(await DB.getMeta('tags')||[]), ...data.tags||[]])).sort());
  if (Array.isArray(data.playlists)) await DB.setMeta('playlists', data.playlists);

  for (const s of data.songs){
    await DB.saveSong({
      id: s.id || null,
      title: s.title||'',
      artist: s.artist||'',
      category: s.category||'',
      tags: s.tags||[],
      createdAt: s.createdAt||Date.now(),
      updatedAt: s.updatedAt||Date.now(),
      pdfName: s.pdfName||'',
      audioName: s.audioName||'',
      pdfBlob: s.pdfB64 ? base64ToBlob(s.pdfB64, s.pdfMime||'application/pdf') : null,
      audioBlob: s.audioB64 ? base64ToBlob(s.audioB64, s.audioMime||'audio/mp3') : null
    });
  }
  await refreshCategories(); await refreshTagsChips(); await renderList(); await renderPlaylists();
  alert('Importação concluída!');
}

/* ===================== Utils ===================== */
const byId = id => document.getElementById(id);
function switchTab(name, btn=null){
  document.querySelectorAll('.tab').forEach(t=>t.classList.remove('active'));
  document.getElementById('tab-'+name).classList.add('active');
  document.querySelectorAll('.tabs button').forEach(b=>b.classList.remove('active'));
  if (btn) btn.classList.add('active'); else document.querySelector(`.tabs button[data-tab="${name}"]`)?.classList.add('active');
}
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
function fileToBlob(file){ return new Promise(res=>{ const r = new FileReader(); r.onload=()=>res(new Blob([r.result],{type:file.type||'application/octet-stream'})); r.readAsArrayBuffer(file); }); }
function blobToBase64(blob){ return new Promise((res,rej)=>{ const r = new FileReader(); r.onload=()=>res(btoa(String.fromCharCode(...new Uint8Array(r.result)))); r.onerror=rej; r.readAsArrayBuffer(blob); }); }
function base64ToBlob(b64, mime='application/octet-stream'){ const bin = atob(b64); const bytes = new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i); return new Blob([bytes],{type:mime}); }
</script>
</body>
</html>
